# コンポーネントを作る

## Reactアプリケーションを起動する

まず、`yarn start`を実行してみます。
この時自動でブラウザが自動で立ち上がり、アプリケーションの初期ページが表示されると思います。

![yarn startした時のReact Applicationの画像](images/react-first.png)

次に`yarn build`を実行してみましょう。デフォルトではbuildと言うディレクトリに複数のディレクトリとファイルが生成されるはずです。

ここで`public/index.html`と生成された`build/index.html`を見比べてみましょう。新たに生成された`build/index.html`にはファイルが一行に圧縮されているのに加え、javascriptのコードが書かれたscriptタグが挿入されているのがわかるかと思います。開発用のコードは主にユーザーに提供する前に

- ユーザーのブラウザやマシンで読みとれる形式にする
- コードやファイルを圧縮する
- コードを難読化する(Script言語はソースコードが利用するユーザーに見えるので変数名や、処理順序が分かりにくいようにする。変数名を1文字にするなどの情報圧縮の副産物的な側面があるので、完全にリバースエンジニアリングが(困難だとしても)不可能でないことには注意しましょう。)
- 使われてないコードを除去する

などと言った過程を踏むようにbuildという作業を行います。buildに含まれる作業はツールによって様々で、詳しいbuildの内容を知りたい場合は利用しているフレームワークについて調べてください。

このCreate React Appで作成されたアプリケーションをユーザーに提供する場合は、このbuildディレクトリ配下のファイル全てを、インターネットを介してhttpまたはhttpsプロトコルでpublicにアクセス可能なホスティングサーバのストレージに配置し、ユーザーのブラウザやhttpクライアントでアクセスしてもらう形で提供することができます。

例えばFirebase HostingやAmazon Amplify, S3,Netlify、Vercelなどのcloudサービスを利用してホスティングすることが可能です。

## Reactのエントリポイントを確認してみる

ここでindex.tsxの中身を見てみると処理のようなコードが見つかると思います。


```tsx:index.tsx
ReactDOM.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
  document.getElementById("root")
);
```

[React.StrictMode](https://ja.reactjs.org/docs/strict-mode.html)の詳細についてはリンク先の記事も参考にしてください。

ReactはVirtual DOM（仮想DOM）と呼ばれる仕組みによって、HTMLのDOMを内包した仮想的なDOMをJavascriptのデータ構造としてメモリに保存し、指定したタグを起点にして内包しているDOMによって書き換えます。上記の例ではrootというidがついたタグを第一引数で表されるReact Componentに書き換える処理を実行するコードになっています。この処理のようにReactのVirtual DOMが内包しているDOMでHTMLを書き換える事をレンダーあるいはレンダリングと呼びます。

この時一度レンダリングされたDOMに対してHTMLのユーザー操作により変更が加えられた時、あるいは、JavascriptからVirtual DOMが持っているパラメータに変更が加えられた時に、Virtual DOMはその差分が生じた部分を検出（Reconcilation）し、HTMLを再レンダリングします。このVirtual DOMが差分検出のために用いるデータオブジェクトをFacebookはfiberと名付け、Reconcilationを行う処理エンジンをFiberと名付け開発しています。FiberやReconcilationの仕組みを詳しく知りたい方は[こちらのリンク](https://ja.reactjs.org/docs/faq-internals.html)を参照してください。

Reactはまた、仮想DOMの中に仮想DOMを階層的に構築することが可能です。それを模しているのが以下の図です。

![Reactのコンポーンネントツリー画像](images/render-tree.png)

[引用元](https://medium.com/@coolram2104/digging-deeper-inside-the-reconciliation-algorithm-of-react-f0d428ba4ae9)

また、Reactにおいては仮想DOMとJavascriptを組み込んだ関数、あるいはClassの事をコンポーネントと呼び、上記の図ではそれぞれのノード、あるいは部分的に木構造を切り出した時にルートにあたるノードが構成する部分木に対応しています。部分木の事をコンポーネントと呼ぶ事に関して違和感を感じる人は、一つの仮想DOMを階層的に出来るということはその逆の木構造になっている仮想DOMを一つの仮想DOMにまとめることが出来るという事実を踏まえて、ノードと部分木が等価に変換可能であるという事を意識するとよいでしょう。

どの大きさの仮想DOMをコンポーネントとして扱うかはユーザーの裁量に委ねられています。しかし、ある程度巨大な仮想DOMは開発中に管理がしにくくなる他、ReactにはReconcilationが行われるコンポーネントを最小限にすることでユーザーのブラウザ上でのアプリケーションの処理速度を向上できるため、一般的には、出来るだけ細かく分割することが推奨されており、また、[ウォーターフォール](https://ja.reactjs.org/docs/concurrent-mode-suspense.html#approach-1-fetch-on-render-not-using-suspense)と呼ばれるコンポーネントの読み込み時間が直列になってしまう現象を防ぐために、出来るだけツリーのNodeを浅くするようにコンポーネントを構成するのがよいです。

後半の章で説明しますが、効率的にコンポーネントツリーを構築するためのデザイン指針として、[アトミックデザイン](https://bradfrost.com/blog/post/atomic-web-design/)というものがあり、多くの組織で採用されていますが、ルール上の定義は曖昧な部分がありReactに導入する場合には運用上の注意、トレードオフ、メリット、デメリットが存在するので、それらを理解した上で、自分達のプロジェクトで取り入れるべきか、また、どういう運用にするべきかを判断するようにしてください。

上記のAppコンポーネントはページ上の全て機能を階層的な仮想DOMに内包しており、仮想DOMの状態遷移によってユーザーの見ているページを動かすという仕組みになっています。

このように、ある１つの仮想DOMにURL遷移を含むユーザーにインタラクションする全ての機能を盛り込んで提供することが可能で、このような方法で提供されるアプリケーションをSPA(Single Page Application)と呼びます。

## Reactアプリケーションの表示内容を変更する

ここから実際にテンプレート上のコードを書き換えていきます。まずはブラウザを開いたまま初期画面に書いてある通りsrc/App.tsxファイルを開いて、

```tsx
Edit src/App.tsx and save to reload.
```
という文字列を
```tsx
Hello World!
```

に書き換えてみましょう。この時、ファイルを保存したタイミングでブラウザで表示されているメッセージが変更されたかと思います。

これは、react-scriptsで起動したReact ApplicationではHMR(Hot Module Replacement)という機能をデフォルトで有効にする設定がなされているためです。HMRは開発中のマシンでホスティングしているWEBページを変更した場合ブラウザ上で表示している内容をreloadせずに変更出来る場合はjavascriptを利用して変更し、再ビルドなどが必要な場合は、自動でbuildし直してreloadして開発をしやすくしてくれる機能です。

一般的にはこれらの機能はReactに特別な機能ではなく、Reactを単体のライブラリとして使う場合にHMRが必要な場合は設定が必要ですが、最近のフレームワークではデフォルトで有効になっていることが多いです。

ここで、src/App.tsxの中身は以下のようになっていますが、

```tsx:src/App.tsx
import React from "react";
import logo from "./logo.svg";
import "./App.css";

function App() {
  return (
    <div className="App">
      <header className="App-header">
        <img src={logo} className="App-logo" alt="logo" />
        <p>Hello World!</p>
        <a
          className="App-link"
          href="https://reactjs.org"
          target="_blank"
          rel="noopener noreferrer"
        >
          Learn React
        </a>
      </header>
    </div>
  );
}

export default App;
```

ここからコンポーネントを階層的に分けてみましょう。例えば以下のようにheaderのタグをWidgetというコンポーネントに切り出して階層的にしてみます。

```tsx:src/App.tsx
import React from "react";
import logo from "./logo.svg";
import "./App.css";

function Widget() {
  return (
    <header className="App-header">
      <img src={logo} className="App-logo" alt="logo" />
      <p>Hello World!</p>
      <a
        className="App-link"
        href="https://reactjs.org"
        target="_blank"
        rel="noopener noreferrer"
      >
        Learn React
      </a>
    </header>
  );
}

function App() {
  return (
    <div className="App">
      <Widget />
    </div>
  );
}

export default App;
```

これで、Appコンポーネント内にWidgetコンポーネントをはめこんで階層的になりました。このようにコンポーネントを分けることで、Widgetコンポーネントはその他のコンポーネントに組み込むことができるようになります。

## Propsを理解する

上記のWidgetコンポーネントは再利用できるようにはなりましたが、表示内容を変更することができません。どのコンポーネントでWidgetコンポーネントを利用したとしてもHello World!という語句やLearn Reactという語句のメッセージが表示されます。これが困らない場合はこれで構いませんが、再利用を目的にする場合は、メッセージを設定できる方が良いと思います。ここで、登場するのがPropsです。Propsは上位のコンポーネントから下位にあたるコンポーネントに対してパラメータを渡すことができる仕組みです。コンポーネントのPropsを有効にするためには関数コンポーネントの場合は関数の第一引数を定義します。これはJSXに渡した属性名とパラメータのセットをkeyとValueに設定したDictionary形式のパラメータで渡されます。ここで、`Hello World!`と表示されている文字列をこのPropsに渡したmessage属性の値`Hello React!`を表示するように変更してみましょう。


```tsx:src/App.tsx
import React from "react";
import logo from "./logo.svg";
import "./App.css";

interface WidgetProps {
  message: string;
}

function Widget(props: WidgetProps) {
  return (
    <header className="App-header">
      <img src={logo} className="App-logo" alt="logo" />
      <p>{props.message}</p>
      <a
        className="App-link"
        href="https://reactjs.org"
        target="_blank"
        rel="noopener noreferrer"
      >
        Learn React
      </a>
    </header>
  );
}

function App() {
  return (
    <div className="App">
      <Widget message="Hello React!" />
    </div>
  );
}

export default App;
```

無事メッセージが変更されたかと思います。
